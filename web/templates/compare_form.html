<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Solo vs Pool Comparison</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/site.css?v=2.1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    .metric-kv { display:flex; justify-content:space-between; gap:1rem; }
    .metric-kv .k { color: #6c757d; }
    .metric-kv .v { font-weight: 600; }

    /* Minimal heatmap styling (no extra deps) */
    .heatmap-grid {
      display: grid;
      gap: 2px;
      width: 100%;
    }
    .heatmap-cell {
      aspect-ratio: 1 / 1;
      border-radius: 3px;
      cursor: default;
    }
    .heatmap-cell.current {
      outline: 2px solid rgba(33,37,41,0.75);
      outline-offset: 1px;
    }
    .heatmap-legend {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      display: inline-block;
      border: 1px solid rgba(0,0,0,0.08);
    }
    .heatmap-axis {
      font-size: 0.85rem;
    }
  </style>
</head>
<body class="bg-body">
  <div class="container container-narrow py-4">

    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1 class="h3 mb-0">Solo vs Pool Risk Comparison</h1>
      <div class="d-flex gap-3">
        <a href="/" class="link-secondary">Home</a>
        <a href="/methods" class="link-secondary">Methods</a>
        <a href="/blog/solo-vs-pool-risk-first/" class="link-secondary">Blog</a>
      </div>
    </div>

    <p class="text-body-secondary">
      New here? Read <a class="link-secondary" href="/blog/solo-vs-pool-risk-first/">why expected value isn’t enough for solo mining</a>.
    </p>

    <div class="card p-3 mb-4">
      <form id="compare-form">
        <div class="row g-3">
          <div class="col-12" id="compute-alert-wrap" style="display:none;"></div>

          <div class="col-md-4">
            <label class="form-label">Coin</label>
            <select name="coin" class="form-select">
              <option value="btc" {% if defaults.coin == 'btc' %}selected{% endif %}>BTC</option>
              <option value="bch" {% if defaults.coin == 'bch' %}selected{% endif %}>BCH</option>
            </select>
          </div>

          <div class="col-md-4">
            <label class="form-label">Hashrate</label>
            <input name="hashrate" class="form-control" value="{{ defaults.hashrate }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Horizon (days)</label>
            <input name="horizon_days" type="number" class="form-control" value="{{ defaults.horizon_days }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Coin price (USD)</label>
            <input name="coin_price_usd" type="number" step="0.01" class="form-control" value="{{ defaults.coin_price_usd }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Electricity cost ($/kWh)</label>
            <input name="electricity_cost_per_kwh" type="number" step="0.001" class="form-control" value="{{ defaults.electricity_cost_per_kwh }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">ASIC power (watts)</label>
            <input name="asic_power_watts" type="number" class="form-control" value="{{ defaults.asic_power_watts }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Pool fee (%)</label>
            <input name="pool_fee_pct" type="number" step="0.001" class="form-control" value="{{ defaults.pool_fee_pct }}">
            <div class="form-text">You can enter 2, 0.02, or 2% (we normalize).</div>
          </div>

          <div class="col-12">
            <details class="mt-1">
              <summary class="text-body-secondary">Advanced</summary>
              <div class="row g-3 mt-1">
                <div class="col-md-4">
                  <label class="form-label">Monte Carlo runs</label>
                  <input name="mc_runs" type="number" class="form-control" value="{{ defaults.mc_runs }}">
                  <div class="form-text">Reserved for later (not used in v1 compare math yet).</div>
                </div>
              </div>
            </details>
          </div>

          <div class="col-md-4">
            <label class="form-label">Histogram scale</label>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="log-y">
              <label class="form-check-label" for="log-y">Log Y (tails)</label>
            </div>
            <div class="form-text">Useful when one bin dominates and tails are hard to see.</div>
          </div>

          <div class="col-md-4">
            <label class="form-label">Heatmap resolution</label>
            <select name="heatmap_steps" class="form-select">
              <option value="11">11 × 11 (fast)</option>
              <option value="15" selected>15 × 15 (default)</option>
              <option value="21">21 × 21 (detailed)</option>
            </select>
            <div class="form-text">Higher resolution is slower (more server work).</div>
          </div>

        </div>

        <div class="mt-3 d-flex gap-2">
          <button type="submit" class="btn btn-primary">Compare</button>

          <button id="share-btn" type="button" class="btn btn-outline-secondary" disabled>
            Copy share link
          </button>
        </div>

        <div class="mt-2 small text-body-secondary" id="share-status"></div>
      </form>
    </div>

    <div id="results" style="display:none;">
      <!-- Headline + EV delta -->
      <div class="card p-3 mb-3">
        <div class="d-flex flex-wrap align-items-baseline justify-content-between gap-2">
          <div>
            <div class="text-body-secondary">Decision signal</div>
            <div class="h5 mb-0" id="headline"></div>
            <div class="small text-body-secondary mt-1" id="headline-sub"></div>
          </div>
          <div class="text-end">
            <div class="text-body-secondary">Expected value delta</div>
            <div class="h5 mb-0" id="ev-delta"></div>
            <div class="small text-body-secondary mt-1">(Solo EV − Pool EV)</div>
          </div>
        </div>
      </div>
      <!-- Key probabilities + interpretation -->
      <div class="row g-3 mb-3">
        <div class="col-md-6">
          <div class="card p-3">
            <div class="text-body-secondary">Key probabilities</div>
            <div class="mt-2 metric-kv">
              <div class="k">P(0 blocks)</div>
              <div class="v" id="p0"></div>
            </div>
            <div class="mt-1 metric-kv">
              <div class="k">P(lose money)</div>
              <div class="v" id="pneg"></div>
            </div>
            <div class="mt-1 metric-kv">
              <div class="k">P(solo underperforms pool)</div>
              <div class="v" id="regret"></div>
            </div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card p-3">
            <div class="text-body-secondary">Interpretation</div>
            <div class="mt-2" id="meaning"></div>
            <div class="small text-body-secondary mt-2">
              Rule of thumb: if <span class="fw-semibold">P(0 blocks)</span> is high, solo behaves like a lottery even if EV is positive.
            </div>
          </div>
        </div>
      </div>

      <div class="row g-3">
        <div class="col-md-6">
          <div class="card p-3">
            <h2 class="h6">Solo</h2>
            <div id="solo-results"></div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card p-3">
            <h2 class="h6">Pool</h2>
            <div id="pool-results"></div>
          </div>
        </div>
      </div>

       <div class="row g-3 mt-2">
         <div class="col-12">
           <div class="card p-3">
             <div class="d-flex justify-content-between align-items-start gap-3 flex-wrap">
               <div>
                 <h2 class="h6 mb-1">Risk Heatmap: P(net &lt; 0)</h2>
                 <div class="text-body-secondary small">
                   X = coin price, Y = electricity cost. Each cell is the probability your solo net is negative.
                 </div>
               </div>
               <div class="heatmap-legend small text-body-secondary">
                 <span class="legend-swatch" style="background:#d1e7dd;"></span><span>&lt;20%</span>
                 <span class="legend-swatch" style="background:#fff3cd;"></span><span>20–50%</span>
                 <span class="legend-swatch" style="background:#ffe5d0;"></span><span>50–80%</span>
                 <span class="legend-swatch" style="background:#f8d7da;"></span><span>&gt;80%</span>
               </div>
             </div>
             <div class="row g-2 mt-2 align-items-center">
               <div class="col-12 col-md-10">
                 <div id="heatmap" class="heatmap-grid" aria-label="Risk heatmap"></div>
               </div>
               <div class="col-12 col-md-2">
                 <div class="heatmap-axis text-body-secondary small">
                   <div class="fw-semibold">Axes</div>
                   <div>Right: higher price</div>
                   <div>Up: higher $/kWh</div>
                 </div>
                 <div class="small text-body-secondary mt-2" id="heatmap-status"></div>
               </div>
             </div>
           </div>
         </div>
       </div>

      <div class="row g-3 mt-2">
        <div class="col-12">
          <div class="small text-body-secondary">
            Bars: probability mass by outcome bin. Lines: <span class="fw-semibold">EV</span> and <span class="fw-semibold">Breakeven (0)</span>. Shading: <span class="fw-semibold">net &lt; 0</span>.
          </div>
        </div>
        <div class="col-md-6">
          <div class="card p-3">
            <h2 class="h6">Solo Net Distribution (USD)</h2>
            <canvas id="solo-histogram"></canvas>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card p-3">
            <h2 class="h6">Solo vs Pool Delta (USD)</h2>
            <canvas id="delta-histogram"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(function () {
  const form = document.getElementById('compare-form');
  const resultsEl = document.getElementById('results');
  const shareBtn = document.getElementById('share-btn');
  const shareStatus = document.getElementById('share-status');
  const logYToggle = document.getElementById('log-y');
  const heatmapEl = document.getElementById('heatmap');
  const heatmapStatus = document.getElementById('heatmap-status');
  const computeAlertWrap = document.getElementById('compute-alert-wrap');

  const headlineEl = document.getElementById('headline');
  const headlineSubEl = document.getElementById('headline-sub');
  const evDeltaEl = document.getElementById('ev-delta');
  const p0El = document.getElementById('p0');
  const pnegEl = document.getElementById('pneg');
  const regretEl = document.getElementById('regret');
  const meaningEl = document.getElementById('meaning');

  let soloChart = null;
  let deltaChart = null;
  let lastData = null;

  function applyQueryParamsToForm() {
    if (!form) return;
    const qs = new URLSearchParams(window.location.search);
    if (!qs || [...qs.keys()].length === 0) return;

    // Whitelist: only accept known fields
    const allowed = new Set([
      'coin',
      'hashrate',
      'horizon_days',
      'coin_price_usd',
      'electricity_cost_per_kwh',
      'asic_power_watts',
      'pool_fee_pct',
      'mc_runs',
      'heatmap_steps',
      'autorun'
    ]);


    for (const [key, rawVal] of qs.entries()) {
      if (!allowed.has(key)) continue;
      if (key === 'autorun') continue; // not a form field
      const el = form.elements.namedItem(key);
      if (!el) continue;

      const val = String(rawVal ?? '');

      // Basic normalization for UX; backend normalization still happens in toPayload().
      if (key === 'coin') {
        el.value = val.trim().toLowerCase();
      } else if (key === 'hashrate') {
        el.value = val.trim().replace(/\s+/g, '').toUpperCase();
      } else {
        el.value = val;
      }
    }

    // URL had inputs, so ensure share link is disabled until user computes.
    if (shareBtn) shareBtn.disabled = true;

    // Optional: clear any stale results if user navigates back with params
    if (resultsEl) resultsEl.style.display = 'none';

    if (qs.get('autorun') === '1') {
     setTimeout(() => { form.requestSubmit(); }, 0);
    }
  }

  // Apply query params once on load
  applyQueryParamsToForm();

  function setComputeAlert(kind, html) {
    if (!computeAlertWrap) return;
    if (!html) {
      computeAlertWrap.style.display = 'none';
      computeAlertWrap.innerHTML = '';
      return;
    }
    const cls = (kind === 'danger') ? 'alert-danger'
      : (kind === 'warning') ? 'alert-warning'
      : 'alert-info';
    computeAlertWrap.innerHTML = `
      <div class="alert ${cls} py-2 mb-0" role="alert">
        ${html}
      </div>
    `;
    computeAlertWrap.style.display = 'block';
  }

  async function safeReadErrorBody(res) {
    try {
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (ct.includes('application/json')) {
        const j = await res.json();
        return JSON.stringify(j, null, 2);
      }
      return await res.text();
    } catch (_) {
      return '';
    }
  }

  function normalizeHashrate(s) {
    if (s == null) return '';
    return String(s).trim().replace(/\s+/g, '').toUpperCase();
  }

  function normalizePoolFee(value) {
    if (value == null) return 0;

    let s = String(value).trim();

    // Handle "2%" style input
    const hasPercent = s.endsWith('%');
    if (hasPercent) {
      s = s.slice(0, -1);
    }

    let n = Number(s);
    if (!Number.isFinite(n) || n < 0) return 0;

    // If user typed 2 (meaning 2%), convert to 0.02
    // Heuristic: anything > 1 is assumed to be percent input.
    if (n > 1 || hasPercent) {
      n = n / 100.0;
    }

    // Clamp to backend-allowed range
    if (n > 0.25) n = 0.25;

    return n;
  }

  function toPayload() {
    const formData = new FormData(form);
    const payload = Object.fromEntries(formData.entries());

    const heatmapSteps = Number(payload.heatmap_steps || 15);
    delete payload.heatmap_steps;

    payload.coin = String(payload.coin || '').trim().toLowerCase();
    payload.hashrate = normalizeHashrate(payload.hashrate);

    payload.horizon_days = Number(payload.horizon_days);
    payload.coin_price_usd = Number(payload.coin_price_usd);
    payload.electricity_cost_per_kwh = Number(payload.electricity_cost_per_kwh);
    payload.asic_power_watts = Number(payload.asic_power_watts);
    payload.pool_fee_pct = normalizePoolFee(payload.pool_fee_pct);
    payload.mc_runs = Number(payload.mc_runs);

    return { payload, heatmapSteps };
  }

  function colorForProb(p) {
    // Buckets (match legend)
    if (p < 0.20) return '#d1e7dd'; // green-ish
    if (p < 0.50) return '#fff3cd'; // yellow-ish
    if (p < 0.80) return '#ffe5d0'; // orange-ish
    return '#f8d7da';              // red-ish
  }

  function renderHeatmap(grid, curPriceUsd, curElecPerKwh) {
    if (!heatmapEl || !grid) return;

    // Backend schema:
    // grid.price_grid: [price...]
    // grid.electricity_grid: [elec...]
    // grid.probability_negative_net: [[p...]] rows by elec, cols by price
    const prices = grid.price_grid || [];
    const elec = grid.electricity_grid || [];
    const z = grid.probability_negative_net || [];

    if (!prices.length || !elec.length || !z.length) {
      heatmapEl.innerHTML = '';
      if (heatmapStatus) heatmapStatus.textContent = '';
      return;
    }

    // grid columns = prices
    heatmapEl.style.gridTemplateColumns = `repeat(${prices.length}, 18px)`;

    // Compute "current" index (nearest) from the form’s current inputs.
    // This avoids needing backend to return a current_index.
    const curX = nearestIndex(prices, Number(curPriceUsd));
    const curY = nearestIndex(elec, Number(curElecPerKwh));

    // Build cells row-major: electricity rows top->bottom (we’ll render high->low so “higher elec” is visually higher)
    const rows = [];
    for (let y = elec.length - 1; y >= 0; y--) {
      for (let x = 0; x < prices.length; x++) {
        const p = Number(z[y][x] ?? 0);
        const div = document.createElement('div');
        div.className = 'heatmap-cell';
        div.style.background = colorForProb(p);

        // Mark current input cell (nearest index)
        const visualY = elec.length - 1 - y;
        if (x === curX && visualY === curY) {
          div.classList.add('current');
        }

        // Tooltip
        const price = Number(prices[x]).toFixed(2);
        const e = Number(elec[y]).toFixed(3);
        div.title = `price=$${price}, elec=$${e}/kWh, P(loss)=${(p*100).toFixed(1)}%`;
        rows.push(div);
      }
    }

    heatmapEl.replaceChildren(...rows);

     if (heatmapStatus) {
      heatmapStatus.textContent =
        `Grid: ${prices.length}×${elec.length} (price $${Number(prices[0]).toFixed(2)}..$${Number(prices[prices.length-1]).toFixed(2)}, ` +
        `elec $${Number(elec[0]).toFixed(3)}..$${Number(elec[elec.length-1]).toFixed(3)}/kWh)`;
    }
  }

  function nearestIndex(arr, target) {
    if (!Array.isArray(arr) || arr.length === 0 || !Number.isFinite(target)) return 0;
    let bestI = 0;
    let bestD = Infinity;
    for (let i = 0; i < arr.length; i++) {
      const v = Number(arr[i]);
      const d = Math.abs(v - target);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI;
  }

  function binIndexForX(histData, x) {
    if (!histData || !Array.isArray(histData.bins) || histData.bins.length === 0) return null;
    const start = Number(histData.bins[0]);
    const w = Number(histData.bin_width || 0);
    if (!Number.isFinite(start) || !Number.isFinite(w) || w <= 0) return null;
    const idx = Math.floor((Number(x) - start) / w);
    if (!Number.isFinite(idx)) return null;
    if (idx < 0) return 0;
    if (idx >= histData.bins.length) return histData.bins.length - 1;
    return idx;
  }

  const histogramAnnotationsPlugin = {
    id: 'histogramAnnotations',
    afterDatasetsDraw(chart, args, pluginOptions) {
      const opts = pluginOptions || {};
      const ctx = chart.ctx;
      const xScale = chart.scales.x;
      const yScale = chart.scales.y;
      if (!xScale || !yScale) return;

      // Shade loss region (bins strictly left of breakeven bin)
      if (opts.lossShade && Number.isInteger(opts.breakevenIndex)) {
        const left = xScale.getPixelForTick(0);
        const right = xScale.getPixelForTick(opts.breakevenIndex);
        const top = yScale.top;
        const bottom = yScale.bottom;
        if (right > left) {
          ctx.save();
          ctx.fillStyle = 'rgba(220,53,69,0.10)'; // bootstrap danger-ish tint
          ctx.fillRect(left, top, right - left, bottom - top);
          ctx.restore();
        }
      }

      function drawVLine(idx, color, label) {
        if (!Number.isInteger(idx)) return;
        const x = xScale.getPixelForTick(idx);
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, yScale.top);
        ctx.lineTo(x, yScale.bottom);
        ctx.stroke();

        if (label) {
          ctx.fillStyle = color;
          ctx.font = '12px sans-serif';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(label, x + 4, yScale.top + 4);
        }
        ctx.restore();
      }

      // Breakeven line (net = 0)
      if (Number.isInteger(opts.breakevenIndex)) {
        drawVLine(opts.breakevenIndex, 'rgba(33,37,41,0.85)', '0');
      }

      // EV line(s)
      if (Number.isInteger(opts.evIndex)) {
        drawVLine(opts.evIndex, 'rgba(13,110,253,0.85)', 'EV');
      }
      if (Number.isInteger(opts.ev2Index)) {
        drawVLine(opts.ev2Index, 'rgba(102,16,242,0.85)', 'EV');
      }
    }
  };

  function renderHistogram(canvasId, histData, label, annotation) {
    const ctx = document.getElementById(canvasId);
    if (!ctx || !histData || !histData.bins) return null;

    const labels = histData.bins.map(b => b.toFixed(0));
    const values = histData.prob.map(p => p * 100.0);

    const useLogY = !!(logYToggle && logYToggle.checked);

    const breakevenIndex = binIndexForX(histData, 0.0);
    const evIndex = (annotation && Number.isFinite(annotation.ev))
      ? binIndexForX(histData, annotation.ev)
      : null;
    const ev2Index = (annotation && Number.isFinite(annotation.ev2))
      ? binIndexForX(histData, annotation.ev2)
      : null;

    return new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: label,
          data: values,
        }]
      },
      options: {
        responsive: true,
        scales: {
          x: {
            title: { display: true, text: 'USD (bin left edge)' }
          },
          y: {
            title: { display: true, text: 'Probability (%)' },
            beginAtZero: true,
            type: useLogY ? 'logarithmic' : 'linear',
            // log scale can't include 0; Chart.js will handle, but keep safe:
            min: useLogY ? 0.001 : undefined
          }
        }
      },
      plugins: [{
        ...histogramAnnotationsPlugin,
        // Per-chart options
        afterDatasetsDraw: histogramAnnotationsPlugin.afterDatasetsDraw
      }],
      // plugin options live here in v4:
      plugins: {
        histogramAnnotations: {
          lossShade: true,
          breakevenIndex: breakevenIndex,
          evIndex: evIndex,
          ev2Index: ev2Index,
        }
      }
    });
  }

  function render(data) {
    lastData = data;

    const p0 = Number(data?.solo?.probability_zero_blocks ?? 0);
    const pneg = Number(data?.solo?.probability_negative_net ?? 0);
    const regret = Number(data?.comparison?.probability_solo_underperforms_pool ?? 0);

    const soloEv = Number(data?.solo?.expected_net_usd ?? 0);
    const poolEv = Number(data?.pool?.expected_net_usd ?? 0);
    const deltaEv = Number(data?.comparison?.expected_value_delta_usd ?? (soloEv - poolEv));

    const p0Pct = (p0 * 100).toFixed(1);
    const pnegPct = (pneg * 100).toFixed(1);
    const regretPct = (regret * 100).toFixed(1);

    if (headlineEl) headlineEl.textContent = `P(solo underperforms pool): ${regretPct}%`;
    if (headlineSubEl) headlineSubEl.textContent =
      `Chance solo ends the horizon with less net $ than pool (given these inputs).`;
    if (evDeltaEl) evDeltaEl.textContent = `${deltaEv >= 0 ? '+' : ''}$${deltaEv.toFixed(2)}`;

    if (p0El) p0El.textContent = `${p0Pct}%`;
    if (pnegEl) pnegEl.textContent = `${pnegPct}%`;
    if (regretEl) regretEl.textContent = `${regretPct}%`;

    if (meaningEl) {
      if (p0 >= 0.85) {
        meaningEl.innerHTML = `<div class="fw-semibold">Lottery profile.</div>
          <div class="text-body-secondary">Most outcomes are “0 blocks” (net ≈ −electricity), with rare big wins.</div>`;
      } else if (p0 >= 0.50) {
        meaningEl.innerHTML = `<div class="fw-semibold">High variance.</div>
          <div class="text-body-secondary">A large share of outcomes are 0 blocks; use solo only if you accept long dry spells.</div>`;
      } else {
        meaningEl.innerHTML = `<div class="fw-semibold">Less extreme variance.</div>
          <div class="text-body-secondary">Outcomes are more spread; EV starts to align better with typical results.</div>`;
      }
    }

    document.getElementById('solo-results').innerHTML = `
      <div>Expected net: $${data.solo.expected_net_usd.toFixed(2)}</div>
      <div>P10 net: $${data.solo.p10_net_usd.toFixed(2)}</div>
      <div>P50 net: $${data.solo.p50_net_usd.toFixed(2)}</div>
      <div>P90 net: $${data.solo.p90_net_usd.toFixed(2)}</div>
      <div>Probability negative net: ${(data.solo.probability_negative_net*100).toFixed(1)}%</div>
      <div>Probability zero blocks: ${(data.solo.probability_zero_blocks*100).toFixed(1)}%</div>
    `;

    document.getElementById('pool-results').innerHTML = `
      <div>Expected net: $${data.pool.expected_net_usd.toFixed(2)}</div>
    `;

    resultsEl.style.display = 'block';
    resultsEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

    if (soloChart) {
      soloChart.destroy();
      soloChart = null;
    }
    if (deltaChart) {
      deltaChart.destroy();
      deltaChart = null;
    }

    if (data.distributions) {
      soloChart = renderHistogram(
        'solo-histogram',
        data.distributions.solo_net_usd,
        'Solo Net (%)',
        {
          ev: data.distributions.solo_expected_net_usd,
          ev2: data.distributions.pool_expected_net_usd
        }
      );

      deltaChart = renderHistogram(
        'delta-histogram',
        data.distributions.delta_vs_pool_usd,
        'Solo - Pool Net (%)',
        {
          ev: data.distributions.solo_expected_net_usd - data.distributions.pool_expected_net_usd
        }
      );
    }
  }

  async function compute() {
    const { payload, heatmapSteps } = toPayload();

    // Clear prior UI state (don’t hide failures)
    setComputeAlert(null, null);
    if (heatmapStatus) heatmapStatus.textContent = '';

    const res = await fetch('/api/v1/compare', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const detail = await safeReadErrorBody(res);
      const detailHtml = detail
        ? `<details class="mt-2"><summary>Details</summary><pre class="small mb-0 mt-2">${detail}</pre></details>`
        : '';
      setComputeAlert('danger', `<span class="fw-semibold">Compare failed</span> (HTTP ${res.status}).${detailHtml}`);
      return;
    }

    const data = await res.json();
    render(data);

    // Heatmap (A): P(solo net < 0) over price x electricity
    try {
      if (heatmapStatus) heatmapStatus.textContent = 'Loading heatmap...';
      const hmRes = await fetch('/api/v1/compare/heatmap', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          coin: payload.coin,
          hashrate: payload.hashrate,
          horizon_days: payload.horizon_days,
          coin_price_usd: payload.coin_price_usd,
          electricity_cost_per_kwh: payload.electricity_cost_per_kwh,
          asic_power_watts: payload.asic_power_watts,
          pool_fee_pct: payload.pool_fee_pct,
          price_steps: heatmapSteps,
          elec_steps: heatmapSteps
        })
      });
      if (!hmRes.ok) {
        const detail = await safeReadErrorBody(hmRes);
        const detailHtml = detail
          ? ` <details class="mt-1"><summary>Details</summary><pre class="small mb-0 mt-1">${detail}</pre></details>`
          : '';
        if (heatmapStatus) heatmapStatus.innerHTML = `Heatmap failed (HTTP ${hmRes.status}).${detailHtml}`;
      } else {
        const hm = await hmRes.json();
        if (hm && hm.grid) {
          renderHeatmap(hm.grid, payload.coin_price_usd, payload.electricity_cost_per_kwh);
          // renderHeatmap already sets heatmapStatus to the grid summary; leave it.
        } else {
          if (heatmapStatus) heatmapStatus.textContent = 'Heatmap returned no grid.';
        }
      }
    } catch (_) {
      if (heatmapStatus) heatmapStatus.textContent = 'Heatmap request failed (network error).';
    }

    shareBtn.disabled = false;
    shareStatus.textContent = '';
  }

  async function share() {
    const { payload } = toPayload();

    const res = await fetch('/api/compare/share', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const detail = await safeReadErrorBody(res);
      const detailHtml = detail
        ? `<details class="mt-2"><summary>Details</summary><pre class="small mb-0 mt-2">${detail}</pre></details>`
        : '';
      setComputeAlert('danger', `<span class="fw-semibold">Share failed</span> (HTTP ${res.status}).${detailHtml}`);
      return;
    }

    const data = await res.json();
    const url = `${window.location.origin}${data.url}`;

    try {
      await navigator.clipboard.writeText(url);
      shareStatus.textContent = 'Share link copied.';
      setTimeout(() => { shareStatus.textContent = ''; }, 1500);
    } catch (e) {
      window.prompt('Copy this link:', url);
    }
  }

  if (form) {
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      await compute();
    });
  }

  if (shareBtn) {
    shareBtn.addEventListener('click', async () => {
      await share();
    });
  }

  if (logYToggle) {
    logYToggle.addEventListener('change', () => {
      // If results already shown, re-render charts in-place.
      // Re-render charts only (no network call). Numbers should not change.
      if (!lastData || !resultsEl || resultsEl.style.display === 'none') return;

      if (soloChart) { soloChart.destroy(); soloChart = null; }
      if (deltaChart) { deltaChart.destroy(); deltaChart = null; }

      if (lastData.distributions) {
        soloChart = renderHistogram(
          'solo-histogram',
          lastData.distributions.solo_net_usd,
          'Solo Net (%)',
          { ev: lastData.distributions.solo_expected_net_usd, ev2: lastData.distributions.pool_expected_net_usd }
        );
        deltaChart = renderHistogram(
          'delta-histogram',
          lastData.distributions.delta_vs_pool_usd,
          'Solo - Pool Net (%)',
          { ev: lastData.distributions.solo_expected_net_usd - lastData.distributions.pool_expected_net_usd }
        );
      }
    });
  }

  // Keep share link aligned with the latest computed inputs.
  if (form && shareBtn) form.addEventListener('input', () => { shareBtn.disabled = true; });

})();
</script>

</body>
</html>